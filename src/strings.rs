pub fn main() {
    {
        let mut s1 = String::from("hello, ");
        let s2 = "bar";
        // push_str()  принимает строковый срез,
        // поэтому владение переменной s2 не теряется
        s1.push_str(s2);
        println!("{}, {}", s1, s2); // VALID
    }
    //  String concat "+" operator
    {
        let s1 = String::from("hi, ");
        let s2 = String::from("evrbdy");
        let s3 = s1 + &s2;
        //  fn add(self, s: &str) -> String {... - сигнатура метода конкатенации
        //  Именно так мы и понимаем, что
        //  добавлять строку можно по ссылке, не забирая владение
        //  а вот первый аргумент - строка к которой прибавляем, как видно из сигнатуры
        //  берется по значению, значит после вызова s3 = s1 + &s2,
        //  объект s1 будет не валиден
    }
    //  Комбинирование с помощью format!
    {
        let s1 = String::from("tic");
        let s2 = String::from("tac");
        let s3 = String::from("toe");
        //  макрос не забирает во владение ни один из аргументов, копируя все аргументы
        let s = format!("{} - {} - {}", s1, s2, s3);
        //  валидно
        println!("{}, {}, {}, {}", s1, s2, s3, s);

    }
    //  Индексирование строк в Rust

    //  Тип String -строковый тип, хранящий символы в кодировке utf-8
    {
        //  в данном пример - каждый символ занимает один байт в UTF-8
        let en: String = String::from("Hello");

        //  длина строки - 12, но длина в байтах - 24
        let ru: String = String::from("Здравсвуйте");
        //  Для данной строки обращение по индексу 0 будет неочевидным,
        //  так как каждый символ кодируется двумя байтами

    }

    //  Методы перебора строк:
    {
        //  Посимвольно
        let ru: String = String::from("Здравсвуйте");
        for ch in ru.bytes() {
            print!("{} ", ch);
        }
        println!();

        //  Побайтово
        for b in ru.bytes() {
            print!("{} ", b);
        }
    }






}
use std::fmt::Display;

pub fn main() {
    //  ВРЕМЕНА ЖИЗНИ
    //  объявление переменной без определения, при попытке использования - CE
    // {
    //     let r;                      // ---------+-- 'a
    //                                 //          |
    //     {                           //          |
    //         let x = 5;              // -+-- 'b  |
    //         r = &x;                 //  |       |
    //     }                           // -+       |
    //                                 //          |
    //     println!("r: {}", r);       //          |
    // }                               // ---------+


    //  ОБОБЩЕННЫЕ ВРЕМЕНА ЖИЗНИ
    //  Сигнатура fn longest показывает, что всессылки должны иметь одинакое время жизни
    //  Для некоторого времени жизни 'a функция принимает два параметра, оба из которых - срезы строк
    //  которые должны существовать как минимум в течение времени жизни, указанном как 'a
    //  Также сигнатура гооврит что возвр. срез строки будет жить как минимум столько же, сколько и время 'а

    //  На практике: время жизни 'a будет привязано ко времни жизни, которое является персечением областей видимости x и y
    //  Возвращённая ссылка также будет действительна в течение меньшего из времён жизни x и y.
    {
        fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
            if x.len() > y.len() {
                x
            } else {
                y
            }
        }

        //  ПРИМЕРЫ
        {
            let string1 = String::from("long string is long");  //  'a
            {
                let string2 = String::from("xyz");              //  'b
                let result = longest(string1.as_str(), string2.as_str()); // 'c = 'a xor 'b = 'b
                println!("The longest string is {}", result);
            }   //  end of 'b
        }   // end of 'a


        {
            let string1 = String::from("long string is long");
            // let result;
            {
                let string2 = String::from("xyz");                //  'b
                // result = longest(string1.as_str(), string2.as_str()); //  'c = 'a xor 'b = 'b
            } //    <---  end of 'b and end of 'c ('b = 'c)
            //  время жизни result такое же как и string2 - внутренная область видимости
            //  а мы пытаемся использовать ее за пределами ее времени жизни
            //  компилтор понял это именно потому, что вовзращаемое значение было проаннотировано 'a -
            //  как наименьшее из времен жизни string1 и string2
            // println!("The longest string is {}", result);   //  CE
        }   // end of 'a
    }
    //  МЫШЛЕНИЕ В ТЕРМИНАХ ВРЕМЕН ЖИЗНИ
    {
        //  возвращаемое значение ниак не соотносится с параметром x и возвр. значением
        //  указывать лайфтайм не надо
        //  возвращаемое значение живет столько же, сколько и x

        // При возврате ссылки из функции, параметр времени жизни для возвращаемого типа должен
        // соответствовать параметру времени жизни одного из аргументов!!!

        fn longest_simple<'a>(x: &'a str, y: &str) -> &'a str {
            x
        }
        {
            let string1 = String::from("Rabbit");
            let string2 = "awdawdawd";

            let res = longest_simple(string1.as_str(), string2);
            println!("The longest: {}", res);
        }
    }


    //  ПРАВИЛА НЕЯВНОГО ВЫВЕДЕНИЯ ВРЕМЕН ЖИЗНИ
    //  Существует три правила неявного выведения времен жизни.
    //  Цель компилятора - выяснить время жизни для каждой ссылки в функции/методе
    //  Если после трех правил ему это не удается, то программа звершается с ошибкой компиляции
    //  Эти правила применяются к объявлениям fn, а также impl блоков.


    // 1. Каждый параметр являющийся ссылкой, получает свой собственный параметр времени жизни.
    // fn foo<'a, 'b>(x: &'a i32, y: &'b i32)


    // 2. Если существует точно один входной параметр времени жизни,
    // то его время жизни назначается всем выходным параметрам:

    // 3. если есть множество входных параметров времени жизни, но один из них является ссылкой &self или &mut self
    // при условии что эта функция является методом структуры или перечисления,
    // то время жизни self назначается временем жизни всем выходным параметрам метода.

    // Пример:
    {
        // 1.   fn first_word<a'>(s: &str) -> &str {
        // 2.   fn first_word<a'>(s: &a' str) -> &a' str {
        // 3. - не метод
        // Компилятор вывел все времена жизни ссылок
        fn first_word(s: &str) -> &str {
            let bytes = s.as_bytes();
            for (i, &item) in bytes.iter().enumerate() {
                if item == b' ' {
                    return &s[0..i];
                }
            }
            &s[..]
        }
    }
    //  Аннотация времён жизни в определении методов
    //  ВРЕМЕНА ЖИЗНИ В СТРУКТУРАХ
    {
        struct ImportantExcerpt<'a> {
            part: &'a str,
        }

        let novel = String::from("Call me Ishmael. Some years ago...");
        let first_sentence = novel.split('.').next().expect("Could not find a '.'");
        let i = ImportantExcerpt { part: first_sentence };

        //  указание лайфтайма в блоке impl<_> можно понимать так:
        //  Данный лайтайм связан с самой СТРУКТУРОЙ, в то время как другие лайфтаймы - аргументами методов
        impl<'a> ImportantExcerpt<'a> {
            //  Примеры:
            //  явно пропишем лайфтаймы, согласно 1 и 3 правилам
            //  Можно было соавить функцию без лайфтаймов, так ка компилятор все вывел за нас.

            fn announce_and_return_part<'f, 's>(&'f self, announcement: &'s str) -> &'f str {
                println!("Attention please: {}", announcement);
                self.part
            }
            //  Применим правила:
            //  Тогда, согласно третьему правилу, у возвращаемого значения будет лайфтайм 'f,
            //  но возвращаемое значение никак не связано с self, его лайфтайм - 't
            //  Для этого метода указание лайфтаймов обязательно!
            fn announce_and_return_other_part<'f, 's, 't>(&'f self, announcement: &'s str, input: &'t str) -> &'t str {
                println!("Attention please {}, in struct: {}", announcement, self.part);
                input
            }
        }
        let s: String = String::from("Hello");
        let a: ImportantExcerpt = ImportantExcerpt { part: s.as_str() };
        a.announce_and_return_part("qwerty");
        a.announce_and_return_other_part("qwerty", "hello");
    }

    //  Обобщённые типы параметров, ограничения типажей и время жизни вместе
    {
        fn longest_with_announcement<'a, T: Display>(x: &'a str, y: &'a str, ann: T) -> &'a str {
            println!("Attention! {}", ann);
            if x.len() > y.len() {
                x
            } else {
                y
            }
        }
    }
    //  ПРИМЕРЫ
    //  Тривиальная обертка над ссылкой
    struct Ref<'a, T> {
        r: &'a T,
    }

    impl<'a, T> Ref<'a, T> {
        fn get<'b>(& 'b self) -> & 'a T {
            self.r  // r  имеет лайфтайм 'a
                    // здесь проиcходит сокращение лайфтайма 'a до 'b
                    // * лайфтайм self ВСЕГДА меньше всех лайфтаймов структуры, что логично
                    // ведь ссылка не может пережить сам объект
                    // возвращаемое значение будет иметь лайфтайм такой же
                    // как и &self - ссылка на структуру
        }
    }


    fn unwrap_ref<'c>(r: Ref<'c, i32>) -> &'c i32 {
        //  здесь неявно создается ссылка &self
        //  которая имеет локальный характер,
        //  у этой ссылки будет свой лайфтайм (назовем его 'local) который выводит сам компилятор
        //  метод выше указывает, что лайфтайм возвр. значения будет таким же, как и self - 'local
        //  let self_ref: &'local Ref<'_, i32> = &r;
        //  а значит возникнет CE - нессответствие лайфтаймов (должен быть 'c а он 'local, меньше)
        //  РЕШЕНИЕ - не нужно сокращать лайфтайм возвр. значения, явно указав -> &'a T
        r.get()
    }
    let a = 5;
    let ra: Ref<i32> = Ref{r: &a};
    let ref_a = unwrap_ref(ra);



    fn f2<'a>(x: &'a i32) -> &'a i32 {
        x
    }

    //  РАБОТАЕТ АНАЛОГИЧНО ПРОСТОЙ ССЫЛКЕ
    fn f3<'a>(ref_val: Ref<'a, i32>) -> &'a i32 {
        ref_val.r
    }
}
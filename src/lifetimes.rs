pub fn main() {
    //  ВРЕМЕНА ЖИЗНИ
    //  объявление переменной без определения, при попытке использования - CE
    // {
    //     let r;                      // ---------+-- 'a
    //                                 //          |
    //     {                           //          |
    //         let x = 5;              // -+-- 'b  |
    //         r = &x;                 //  |       |
    //     }                           // -+       |
    //                                 //          |
    //     println!("r: {}", r);       //          |
    // }                               // ---------+



    //  ОБОБЩЕННЫЕ ВРЕМЕНА ЖИЗНИ
    //  Сигнатура fn longest показывает, что всессылки должны иметь одинакое время жизни
    //  Для некоторого времени жизни 'a функция принимает два параметра, оба из которых - срезы строк
    //  которые должны существовать как минимум в течение времени жизни, указанном как 'a
    //  Также сигнатура гооврит что возвр. срез строки будет жить как минимум столько же, сколько и время 'а

    //  На практике: время жизни 'a будет привязано ко времни жизни, которое является персечением областей видимости x и y
    //  Возвращённая ссылка также будет действительна в течение меньшего из времён жизни x и y.
    {
        fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
            if x.len() > y.len() {
                x
            } else {
                y
            }
        }

        //  ПРИМЕРЫ
        {
            let string1 = String::from("long string is long");  //  'a
            {
                let string2 = String::from("xyz");              //  'b
                let result = longest(string1.as_str(), string2.as_str()); // 'c = 'a xor 'b = 'b
                println!("The longest string is {}", result);
            }   //  end of 'b
        }   // end of 'a


        {
            let string1 = String::from("long string is long");
            let result;
            {
                let string2 = String::from("xyz");                //  'b
                result = longest(string1.as_str(), string2.as_str()); //  'c = 'a xor 'b = 'b
            } //    <---  end of 'b and end of 'c ('b = 'c)
            //  время жизни result такое же как и string2 - внутренная область видимости
            //  а мы пытаемся использовать ее за пределами ее времени жизни
            //  компилтор понял это именно потому, что вовзращаемое значение было проаннотировано 'a -
            //  как наименьшее из времен жизни string1 и string2
            println!("The longest string is {}", result);   //  CE
        }   // end of 'a
    }
    //  МЫШЛЕНИЕ В ТЕРМИНАХ ВРЕМЕН ЖИЗНИ
    {
        //  возвращаемое значение ниак не соотносится с параметром x и возвр. значением
        //  указывать лайфтайм не надо
        //  возвращаемое значение живет столько же, сколько и x

        // При возврате ссылки из функции, параметр времени жизни для возвращаемого типа должен
        // соответствовать параметру времени жизни одного из аргументов!!!

        fn longest_simple<'a>(x: &'a str, y: &str) -> &'a str {
            x
        }
        {
            let string1 = String::from("Rabbit");
            let string2 = "awdawdawd";

            let res = longest_simple(string1.as_str(), string2);
            println!("The longest: {}", res);
        }
    }
    //  ВРЕМЕНА ЖИЗНИ В СТРУКТУРАХ
    {

    }

    //  ПРАВИЛА НЕЯВНОГО ВЫВЕДЕНИЯ ВРЕМЕН ЖИЗНИ
    {

    }


}
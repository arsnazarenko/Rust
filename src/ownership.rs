
fn takes_ownership(some_string: String) {   // объект попадает в скоуп текущей функции
    println!("{}", some_string);
}   //  some_string.drop()

fn makes_copy(some_integer: i32) {  // объект попадает в скоуп текущей функции
    println!("{}", some_integer);
}   //  выход из скоупа - удаление локальной переменной со стэка

fn gives_ownership() -> String {
    let some_string: String = String::from("hello_from_fn");
    some_string //  передача вледения переменной в месте вызова
}

fn takes_and_gives_back(a_string: String) -> String {   // объект попадает в скоуп текущей функции
    a_string    //  передача вледения переменной в месте вызова
}

fn calculate_length(s: String) -> (String, usize) {
    let length: usize = s.len();
    (s, length)
}

fn calculate_length_by_ref(s: &String) -> usize {
    // *s - операция разыменования по аналогии с указателями в C++
    // на самом деле при вызове методов у объекта, происходит автоматическое разыменование
    (*s).len()
    //  время жизни локальной переменной s заканчивается, но так как это просто ссылка
    //  вызов деструктора у объекта, на который указывает ссылка, не происходит
}

fn change_str(some_str: &mut String) {
    some_str.push_str(" for this example");
}

pub fn test() {
    //  ПОНЯТИЕ ВЛАДЕНИЯ

    //  Строковый литерал - неизменяемое значение, размер известен на момент компиляции
    //  хранится на стэке
    //  &str - это срез массива char'ов ( [u8; N] )
    //  Срез - это объект, который хранит указатель на массив и его размер
    //  по аналогии с С: срез - указатель на массив, но Rust контролирует выход за границы массива,
    //  поэтому помимо указателя на первый элемент массива такой объект хранит его длину, чтобы на
    //  этапе компиляции выявлять такую ошибку
    //  Но с точки зрения использования - это обычный указатель на массив
    {
        let s: &str = "hello";
        //  объект доступен для работы с ним в этой области видимости
        //  удаление объекта
    }

    //  String - сложный тип данных, память для значение выделяется а куче
    //  поэтому количество текста не обязтельно должно быть известно во время компиляции
    {
        let mut my_str: String = String::from("hello");//  аллоцирование памяти под строку в куче
        my_str.push_str(", world!");
        println!("{}", my_str);
        //  вызов деструктора drop()
    }

    {
        let s1: String = String::from("first");
        let s2 = s1;    // происходит move, s1 перестает быть валидной
        //  println!("{}", s1); - CE
        println!("{}", s2);
        //  вызов деструктора s2.drop()
    }

    {
        let s3: String = String::from("Home");
        //  происходит глубокое копирование объекта:
        //  аллоцируется память, и данные из кучи копируются в нее
        let s4: String = s3.clone();
        //  оба объекты валидны
        println!("{}", s3);
        println!("{}", s4);
        //  s3.drop(); s4.drop();
    }

    {
        //  ВЛАДЕНИЕ И ФУНКЦИИ
        let s = String::from("best string");
        takes_ownership(s);
        // println!("{}", ss); - CE, ss was moved into fn takes_ownership();
        let x: i32 = 5;
        makes_copy(x);
        println!("{}", x);
    }
    //  Владение функции
    {
        let s1: String = gives_ownership();

        let s2: String = String::from("astroworld");

        let s3: String = takes_and_gives_back(s2);
    }

    //  ПЕРЕДАЧА И ВОЗВРАТ КОТЕЖЕЙ

    {
        let s1: String = String::from("hello");
        //  деструктуризация кортежа
        let (s2, len) = calculate_length(s1);
        //  переменная s1 здесь уже невалидна, мы обязаны возвращать
        println!("The length of '{}' is {}.", s2, len);
    }
    //  ССЫЛОЧНЫЕ ПЕРЕМЕННЫЕ И ЗАИМСТВОВАНИЕ
    {
        let s1 = String::from("Hello everyone!");
        let len = calculate_length_by_ref(&s1);
        //  переменная s1 валидна, так как мы ее позаимствовали, вместо того
        //  чтобы передать ее во владание функции
        println!("The length of '{}' is '{}'.", s1, len);
    }
    //  ИЗМЕНЯЕМЫЕ ССЫЛОЧНЫЕ ПЕРЕМЕННЫЕ
    {
        let mut s: String = String::from("It's mutable hello");
        //  операция взятия указателя, через который будет доступно изменение объекта
        change_str(&mut s);
        println!("The length of '{}' is '{}'.",s,  s.len());
    }

    {
        //  Для изменяемых ссылочных переменных есть одно большое ограничение:
        //  МОЖНО ИМЕТЬ ТОЛЬКО ОДНУ ИЗМЕНЯЕМУЮ ССЫЛОЧНУЮ ПЕРЕМЕННУЮ
        //  НА ЧАСТЬ ДАННЫХ В ОПРЕДЕЛЕННОЙ ОБЛАСТИ ВИДИМОСТИ!!

        let mut s: String = String::from("Bad example!!");
        let r1: &mut String = &mut s;
        //  время жизни двух изменяемых ссылок на один и тот же ресур пересекается
        //  fixme: let r2: &mut String = &mut s; - CE
        //  fixme: println!("{}, {}", *r1, *r2);
    }

    {
        let mut s: String = String::from("Hi, girls :)");
        let r1: &String = &s;   //  все норм
        let r2: &String = &s;   //  все норм
        //  Мы не можем иметь ИЗМЕЯЕМУЮ ссылочную переменную, пока существует
        //  НЕИЗМЕНЯЕМАЯ ссылочная переменная.
        //  Пользователи неизменяемой ссылки не ожидают внезапного изменения
        //  значения на которые она указывает!
        //  Тем не менее, наличие множества неизменяемых переменных допускается, т.к. ни один из
        //  читающих данные не может изменить данные, которые все остальные также читают.
        // fixme: let r3: &mut String = &mut s;   // - CE

        // println!("{}, {} and {}", r1, r2, r3);

    }
}



